# 现有压缩算法略读

本小白为了更清楚的了解压缩算法有关的内容，去囫囵吞枣地临时抱佛脚学习了一下最经典的几种无损压缩算法。

下面是我对其的一些简要理解，若有不对请各位指出，这将帮助我学习，谢谢



[TOC]



## 1.Huffman编码

Huffman编码的本质是基于**频率**。它将出现频率高的字符用短的编码表示，出现频率低等等字符用长的编码表示。

那么它具体是如何操作的呢？首先它先遍历文件数据，统计出来文件中每个不同字符的出现频率。

然后用**最小堆**构建一个优先队列，利用优先队列构建**Huffman树**，再根据树得到编码表。

最后根据编码表替换原有字符，新的数据和编码表就是得到的压缩结果。

解压的过程就是根据Huffman树（即编码表），按二进制位，树从根节点开始进行移动，在叶子节点找到所对应的字符并替换。再回到根节点继续解析，直到解压完成。

### 优缺点

优点是利用贪心策略构建最优二叉树。能够实现**最优前缀码**，压缩率很高，没有任何一个数据是另外一个数据的前缀（比如01和011这种就不会出现），不会造成混淆和歧义使得解压出，而且简单高效。

缺点是要提前遍历统计频率，仅仅适合于**静态数据**（JPEG就是用了一个固定的Huffman树，避免每次统计）。对于小文件来讲，因为需要附上编码表，可能压缩起来并不划算。而且Huffman编码对于**重复序列**的压缩率不是很理想，对于重复序列支持很好的算法有LZ77和LZW，这个一会儿我也写上来（感觉变成我的学习笔记了）。


### 算法具体流程

#### 构建最小堆

最小堆是一棵**完全二叉树**，满足每个节点的值小于等于其子节点的值的性质。而且完全二叉树的结构可以用数组高效存储，**无需用到指针**。

那么最小堆如何构建呢？这里我们假设有几个字符，它们的出现频次分别为 `[1, 4, 2, 3, 6, 5, 1]`.

首先我们需要知道最小堆如何用数组表示：如果父节点索引为i，那么左子节点索引为`2i+1`，右子节点为`2i+2`。同样可以得到当子节点索引为j时，父节点索引为 `⌊(j-1)/2⌋`。

当新元素插入堆中，我们将元素添加到数组的末尾。然后不断与父节点比较，若比父节点小，则交换位置。这个操作我们称之为**上浮**。而**下沉**则是从根开始，不断与更小的子节点交换，直到满足堆性质。**构建堆**的过程就是从最后一个非叶子节点开始，向前逐个节点执行下沉操作。

首先我们根据完全二叉树的性质，得到最后一个非叶子节点的索引为 `⌈n/2⌉ - 1`。
我们假设的数组的长度 `n = 7`，所以最后一个非叶子节点索引为2。那么我们需要处理的节点索引是从2到0。

从最后一个非叶子结点（索引2）开始比较，它自己**值为2**,、它的左孩子索引为5，值为5、右孩子索引为6，**值为1**。所以我们比较2、5和1，得到1更小。所以交换这个节点和它的右孩子（即索引2和6交换，**值2和1交换**）。

我们此刻得到数组`[1, 4, 1, 3, 6, 5, 2]`

然后比较索引1，它的**值为4**、它的左孩子索引为3，**值为3**、右孩子索引为4，**值为6**。所以我们比较4、3和6，得到3更小。所以交换这个节点和它的左孩子（即索引1和3交换，**值4和3交换**）。

我们此刻得到数组`[1, 3, 1, 4, 6, 5, 2]`

最后我们比较索引1，它的值为1，左孩子和右孩子分别值为3和1，已经是最小，**无需交换**。

所以最后我们得到数组**`[1, 3, 1, 4, 6, 5, 2]`**，即**最小堆**。形象的表示为

```text
        1
      /   \
     3     1
    / \   / \
   4  6  5   2
```



#### 得到降序排列

每次将堆顶最小值与当前堆的最后一个元素交换，缩小堆范围并重新调整堆。重复n-1次就能得到降序排列的数组。

在本假设中，堆顶先与索引6交换，缩小堆的范围到索引0~5，得到`[2,3,1,4,6,5,1]`。此时前6个元素未排序。再调整堆顶使其下沉，得到`[1,3,2,4,6,5]`。

然后新的堆顶再与索引5交换，再缩小范围。最终会得到数组**`[6,5,4,3,2,1,1]`**



#### 构建Huffman树

每次从队列中取出两个频率最小的节点。然后创建一个新节点，其频率为这两个节点的频率之和，将新节点重新放回队列中。
一直重复直到队列中只剩根节点。

还是用例子来理解：

1.取出两个最小的1，生成父节点2，放回队列。队列变为 `[2, 2, 3, 4, 5, 6]`
2.取出两个2，生成父节点4，队列变为`[3, 4, 4, 5, 6]`
3.取出3和4，生成父节点7，队列变为 `[4, 5, 6, 7]`
4.取出4和5，生成父节点9，队列变为 `[6, 7, 9]`
5.取出6和7，生成父节点13，队列变为` [9, 13]`
6.取出9和13，生成根节点22。

 ```
          22
        /    \
       9      13
      / \     / \
     4   5   6   7
    / \         / \
   2   2       3   4
      / \ 
     1   1 
   ```



#### 生成编码表

假设0为左，1为右，频次对应的字符分别为`[A, B, C, D, E, F, G]`那么我们可以得到：

**A** 1：从根出发，路径为左左右左  **0010**

**B** 4：路径为右右右  **111**

**C** 2：路径为左左左  **000**

**D** 3：路径为右右左  **110**

**E** 6：路径为右左  **10**

**F** 5：路径为左右  **01**

**G** 1：路径为左左右右  **0011**

