# 现有压缩算法略读

本小白为了更清楚的了解压缩算法有关的内容，去囫囵吞枣地临时抱佛脚学习了一下最经典的几种无损压缩算法。

下面是我对其的一些简要理解，若有不对请各位指出，这将帮助我学习，谢谢



[TOC]



## 1.Huffman编码

Huffman编码的本质是基于**频率**。它将出现频率高的字符用短的编码表示，出现频率低等等字符用长的编码表示。

那么它具体是如何操作的呢？首先它先遍历文件数据，统计出来文件中每个不同字符的出现频率。

然后用**最小堆**构建一个优先队列，利用优先队列构建**Huffman树**，再根据树得到编码表。

最后根据编码表替换原有字符，新的数据和编码表就是得到的压缩结果。

解压的过程就是根据Huffman树（即编码表），按二进制位，树从根节点开始进行移动，在叶子节点找到所对应的字符并替换。再回到根节点继续解析，直到解压完成。

### 优缺点

优点是利用贪心策略构建最优二叉树。能够实现**最优前缀码**，压缩率很高，没有任何一个数据是另外一个数据的前缀（比如01和011这种就不会出现），不会造成混淆和歧义使得解压出，而且简单高效。

缺点是要提前遍历统计频率，仅仅适合于**静态数据**（JPEG就是用了一个固定的Huffman树，避免每次统计）。对于小文件来讲，因为需要附上编码表，可能压缩起来并不划算。而且Huffman编码对于**重复序列**的压缩率不是很理想，对于重复序列支持很好的算法有LZ77和LZW，这个一会儿我也写上来（感觉变成我的学习笔记了）。


### 算法具体流程

#### 构建最小堆

最小堆是一棵**完全二叉树**，满足每个节点的值小于等于其子节点的值的性质。而且完全二叉树的结构可以用数组高效存储，**无需用到指针**。

那么最小堆如何构建呢？这里我们假设有几个字符，它们的出现频次分别为 `[1, 4, 2, 3, 6, 5, 1]`.

首先我们需要知道最小堆如何用数组表示：如果父节点索引为i，那么左子节点索引为`2i+1`，右子节点为`2i+2`。同样可以得到当子节点索引为j时，父节点索引为 `⌊(j-1)/2⌋`。

当新元素插入堆中，我们将元素添加到数组的末尾。然后不断与父节点比较，若比父节点小，则交换位置。这个操作我们称之为**上浮**。而**下沉**则是从根开始，不断与更小的子节点交换，直到满足堆性质。**构建堆**的过程就是从最后一个非叶子节点开始，向前逐个节点执行下沉操作。

首先我们根据完全二叉树的性质，得到最后一个非叶子节点的索引为 `⌈n/2⌉ - 1`。
我们假设的数组的长度 `n = 7`，所以最后一个非叶子节点索引为2。那么我们需要处理的节点索引是从2到0。

从最后一个非叶子结点（索引2）开始比较，它自己**值为2**,、它的左孩子索引为5，值为5、右孩子索引为6，**值为1**。所以我们比较2、5和1，得到1更小。所以交换这个节点和它的右孩子（即索引2和6交换，**值2和1交换**）。

我们此刻得到数组`[1, 4, 1, 3, 6, 5, 2]`

然后比较索引1，它的**值为4**、它的左孩子索引为3，**值为3**、右孩子索引为4，**值为6**。所以我们比较4、3和6，得到3更小。所以交换这个节点和它的左孩子（即索引1和3交换，**值4和3交换**）。

我们此刻得到数组`[1, 3, 1, 4, 6, 5, 2]`

最后我们比较索引1，它的值为1，左孩子和右孩子分别值为3和1，已经是最小，**无需交换**。

所以最后我们得到数组**`[1, 3, 1, 4, 6, 5, 2]`**，即**最小堆**。形象的表示为

```text
        1
      /   \
     3     1
    / \   / \
   4  6  5   2
```



#### 得到降序排列

每次将堆顶最小值与当前堆的最后一个元素交换，缩小堆范围并重新调整堆。重复n-1次就能得到降序排列的数组。

在本假设中，堆顶先与索引6交换，缩小堆的范围到索引0~5，得到`[2,3,1,4,6,5,1]`。此时前6个元素未排序。再调整堆顶使其下沉，得到`[1,3,2,4,6,5]`。

然后新的堆顶再与索引5交换，再缩小范围。最终会得到数组**`[6,5,4,3,2,1,1]`**



#### 构建Huffman树

每次从队列中取出两个频率最小的节点。然后创建一个新节点，其频率为这两个节点的频率之和，将新节点重新放回队列中。
一直重复直到队列中只剩根节点。

还是用例子来理解：

1.取出两个最小的1，生成父节点2，放回队列。队列变为 `[2, 2, 3, 4, 5, 6]`
2.取出两个2，生成父节点4，队列变为`[3, 4, 4, 5, 6]`
3.取出3和4，生成父节点7，队列变为 `[4, 5, 6, 7]`
4.取出4和5，生成父节点9，队列变为 `[6, 7, 9]`
5.取出6和7，生成父节点13，队列变为` [9, 13]`
6.取出9和13，生成根节点22。

 ```
          22
        /    \
       9      13
      / \     / \
     4   5   6   7
    / \         / \
   2   2       3   4
      / \ 
     1   1 
   ```



#### 生成编码表

假设0为左，1为右，频次对应的字符分别为`[A, B, C, D, E, F, G]`那么我们可以得到：

**A** 1：从根出发，路径为左左右左  **0010**

**B** 4：路径为右右右  **111**

**C** 2：路径为左左左  **000**

**D** 3：路径为右右左  **110**

**E** 6：路径为右左  **10**

**F** 5：路径为左右  **01**

**G** 1：路径为左左右右  **0011**


## 2.LZ77算法

LZ77的核心是利用**滑动窗口**技术，在已处理的数据中查找当前待压缩数据的**重复**模式，并用更短的指针（**三元组**）表示这些重复部分。

首先先初始化滑动窗口，然后从当前位置开始查找最长匹配，然后生成三元组，并将窗口滑动匹配长度+1的距离。并重复这些步骤直到所有数据都压缩完成。



### 优缺点

LZ77的优点在于能够无损的**实时动态**的压缩数据，并但对于**重复数据**具有很好的压缩效率（PNG图象压缩用的就是基于LZ77的算法）。

但是缺点也很明显，那就是对于重复模式较少的数据的压缩率非常**不理想**，而且寻找最长匹配可能会有一定的耗时。

所以我们经常把Huffman编码和LZ77进行结合，达到高效的压缩：比如ZIP文件格式。



### 算法具体流程

#### 初始化滑动窗口

首先我们要了解LZ77算法中的出现的一些基本概念，方便之后的理解。

**滑动窗口**是一个动态移动的数据范围，用于限制内存使用，仅仅关注最近利用得到的一部分数据。它分为两部分，**查找缓冲区**和**前向缓冲区**，分别保存历史数据和待处理的后续数据。窗口大小固定，随数据处理动态滑动。

**三元组**是指偏移量、匹配长度和下一个字符。**偏移量**是重复字符串在查找缓冲区中的起始位置距离当前点的偏移，**匹配长度**是重复字符串的长度，**下一个字符**是匹配后的第一个不匹配字符。

为了方便理解，我们还是举个例子。假设现在我们有一份文件的数据里面有一串字符串，滑动窗口长度大于这串字符串的长度（空格为了分隔字符便于阅读，实际上是没有的）

**`A B A B A B A A B A B A B X Y Z A B A B A B`**

我们初始化滑动窗口为

```
查找缓冲区: []  
前向缓冲区: [A B A B A B A A B A B A B X Y Z A B A B A B]
```



#### 寻找最长匹配并生成三元组

首先处理前向缓冲区第一个字符A，查找缓冲区为空，无匹配。
输出**`(0, 0, A)`**，然后滑动窗口1位。得到

```
查找缓冲区: [A]  
前向缓冲区: [B A B A B A A B A B A B X Y Z A B A B A B]
```

处理前向缓冲区第2个字符B，查找缓冲区无匹配。
输出**`(0, 0, B)`**，然后滑动窗口1位。得到

```
查找缓冲区: [A B]  
前向缓冲区: [A B A B A A B A B A B X Y Z A B A B A B]
```

继续处理前向缓冲区中第三个字符A，这时候查找缓冲区中有**匹配**了！A出现在位置1，匹配长度为2（AB）。
输出**` (2, 2, A)`**，意思是退后2位复制2位长度，下一个字符是A。再滑动窗口3位（匹配长度+下一字符）。

```
查找缓冲区: [A B A B]  
前向缓冲区: [A B A A B A B A B X Y Z A B A B A B]
```

那么再下一步就会输出**`(4, 3, A)`**，意思是退后4位复制3位长度（ABA），下一个字符是A。滑动窗口4位。

```
查找缓冲区: [A B A B A B A]  
前向缓冲区: [B A B A B X Y Z A B A B A B]
```

再下一步输出**`(6, 3, A)`**，退后6位复制3位长度（BAB），下一个字符是A，滑动窗口4位。

```
查找缓冲区: [A B A B A B A B A B]  
前向缓冲区: [B X Y Z A B A B A B]
```

处理前向缓冲区当前字符B，查找缓冲区中最长匹配为1，距离为1。输出 **`(1, 1, X)`**，然后滑动窗口2位（匹配长度1加上未匹配的下一个字符）。得到

```
查找缓冲区: [A B A B A B A B A B B X]   
前向缓冲区: [Y Z A B A B A B]
```

Y和Z都无匹配，略过不详细展开。得到

```
查找缓冲区: [A B A B A B A B A B B X Y Z]   
前向缓冲区: [A B A B A B]
```

最后处理前向缓冲区字符A，查找缓冲区中最长匹配为ABABAB，长度为6，距离为12。
输出 **`(12, 6,END)`**，滑动窗口 6 位后，前向缓冲区为空，编码结束。最终得到三元组序列，**压缩完成**

```
(0, 0, A) (0, 0, B) (2, 2, A) (4, 3, A) (6, 3, A) (1, 1, X) (0, 0, Y) (0, 0, Z) (12, 6, END)
```

通过三元组的指引将内容复制到指定的位置，就是**解压**


## 3.LZW算法

LZW算法是LZ77算法的改进和拓展算法。和LZ77的区别在于**不依赖滑动窗口**，而是通过逐步扩展**字典**来捕捉全局重复模式。通过初始化字典，通过动态地逐步匹配和扩展字典来囊括所有的重复模式字符串。将字符串映射为字典中的编码，使得码字更短。



#### 优缺点

优点是可以高效处理**长重复字符串**，而且解码过程简单，仅需编码后的整数序列和初始字典，无需额外元数据，适合**流式数据**

缺点也很明显，首先是对于**短重复不敏感**，前面部分的压缩率较低。而且由于LZW算法的字典可能膨胀，会使得**内存消耗大**。



## 算法具体流程

#### 初始化字典

首先我们初始化一个包含所有单字符的字典（假设基于ASCII码，即0-255个编码），如下

| 字符 | 编码 |
| :--: | :--: |
|  A   |  65  |
|  B   |  66  |
|  X   |  88  |
|  Y   |  89  |
|  Z   |  90  |
| ...  | ...  |



#### 逐步匹配和扩展字典

还是使用之前在LZ77算法中使用的**`A B A B A B A A B A B A B X Y Z A B A B A B`**

匹配的步骤是首先获取**当前前缀P**（初始为空），**下一个字符C**。

当`P+C`在字典中时，更新`P=P+C`

否则先输出P的编码，然后将`P+C`加入字典中，更新`P=C`

那么实操示例步骤如下：

| 步骤 | 当前前缀 (P) | 下一字符 (C) | P+C 是否在字典？ |       操作       | 输出编码 |  新增字典条目  | 下一 P |
| :--: | :----------: | :----------: | :--------------: | :--------------: | :------: | :------------: | :----: |
|  1   |     `A`      |     `B`      |        否        |  输出 `65` (A)   |    65    |  **256 → AB**  |  `B`   |
|  2   |     `B`      |     `A`      |        否        |  输出 `66` (B)   |    66    |  **257 → BA**  |  `A`   |
|  3   |     `A`      |     `B`      |   是（256=AB）   |  扩展 P 为 `AB`  |    -     |       -        |  `AB`  |
|  4   |     `AB`     |     `A`      |        否        | 输出 `256` (AB)  |   256    | **258 → ABA**  |  `A`   |
|  5   |     `A`      |     `B`      |   是（256=AB）   |  扩展 P 为 `AB`  |    -     |       -        |  `AB`  |
|  6   |     `AB`     |     `A`      |  是（258=ABA）   | 扩展 P 为 `ABA`  |    -     |       -        | `ABA`  |
|  7   |    `ABA`     |     `B`      |        否        | 输出 `258` (ABA) |   258    | **259 → ABAB** |  `B`   |
|  8   |     `B`      |     `A`      |   是（257=BA）   |  扩展 P 为 `BA`  |    -     |       -        |  `BA`  |
|  9   |     `BA`     |     `B`      |        否        | 输出 `257` (BA)  |   257    | **260 → BAB**  |  `B`   |
|  10  |     `B`      |     `A`      |   是（257=BA）   |  扩展 P 为 `BA`  |    -     |       -        |  `BA`  |
| ...  |     ...      |     ...      |       ...        |       ...        |   ...    |      ...       |  ...   |



我们来解析一下关键的步骤，以方便理解

步骤4：当 `P=AB` 遇到 `C=A`，`ABA` 不在字典，于是输出 `AB` 的编码 `256`，将 `ABA` 加入字典（258），重置 `P=A`。

**步骤6**：此时 `P=AB` 再次遇到 `C=A`，由于 步骤4 已添加 `ABA`（258），直接扩展 `P=ABA`，无需输出。

**步骤7**：`P=ABA` 遇到 `C=B`，`ABAB` 不在字典 → 输出 `ABA` 的编码 `258`，添加 `ABAB`（259），重置 `P=B`。

最终编码序列会是如下形式：

```
65 (A), 66 (B), 256 (AB), 258 (ABA), 258 (ABA), 257 (BA), ... 
```

#### 解压流程

首先还是初始化字典，与压缩时相同，初始字典包含单字符。

然后逐步解码与扩展字典，先读取第一个码字，解码为字符P。然后循环读取下一个码字

此时如果码字在字典中：解码为字符串C。

如果不在那么`C = P + P[0]`（处理边界情况），输出C，将 `P + C[0]` 添加到字典，更新 `P = C`

